WHAT IS REACT?
  React, or ReactJs, is a JavaScript library for building user interfaces and developing web applications.
  React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.
  I. How to add React to an HTML page?
    - add <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    - add <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  II. Declarative:
    React is declarative. 
    Being declarative means I can tell the computer WHAT to do and the computer can handle the details, while being imperative means I have to tell the computer HOW to do WHAT steps by steps.
  III. Composable and Reusable:
    Elements are the smallest building blocks of a Web page that describe what you want to see on the page. And, components are made of elements.
    Unlike browser DOM elements, React elements are plain JavaScript objects created and returned by JSX that represents DOM elements. And, React components are essentially functions that return React elements.
    Components let you split the UI into independent reusable pieces.

WHAT IS REACTDOM?
  ReactDOM is a global variable of the ReactDOM library.
  React DOM is used to render React components and take care of efficiently updating the DOM to match the React elements. It compares the elements and their children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.
  I. Rendering Elements:
    ReactDOM.render(
      <>React elements</>,
      document.getElementById("root-element")
    );
  II. Root Element:
    A root DOM node/container is required to mark the spot where React DOM should display its components on the HTML page. It will be managed by React DOM.
    To declare a root element:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
        <>React elements</>
      );    
    Web pages built with just React usually have a single root DOM node. If you are integrating React into an existing page, you may have as many isolated root DOM nodes as you like.
  III. React Components:
    To declare a React component:
    1. as a variable:
      const variableName = (
        <>React elements</>
      );
      ReactDOM.render(variableName, document.getElementById("root-element"));
    2. as a function component:
      function FunctionName() {
        return (
          <>React elements</>
        );
      }
      ReactDOM.render(<FunctionName />, document.getElementById("root-element"));
    3. as a class component:
      class ClassName extends React.Component {
        render() {
          return (
            <>React elements</>
          );
        }
      }
      ReactDOM.render(<ClassName />, document.getElementById("root-element"));
    All React elements must be nested in one single parent element/tag. Fragment tags "<></>" can be used as the parent tag.
    React elements are immutable, which means they, their children, and their attributes can't be changed. The only way to update the rendered element is to create a new element and re-render it.

WHAT IS JSX?
  JSX, stands for JavaScript XML, is a syntax extension to JavaScript, which produces React elements.
  JSX makes it easier to write HTML and JavaScript in one file.
  React is what defines JSX, so JSX needs to be used together with React.
  I. How to add JSX to an HTML page?
    1. Method 1:
        - add <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        - add <script src="script.js" type="text/babel"></script>
      This method may slow down your Website and isn't suitable for production.
    2. Method 2:
        - download Node.js
        - run npm init -y
        - run npm install babel-cli@6 babel-preset-react-app@3
        - create a "src" folder where the "script.js" file will locate
        - run npx babel --watch src --out-dir . --presets react-app/prod
      This method is the setup for a production-ready JSX preprocessor to convert all "script" tags automatically.
  II. Object Representation:
    Babel compiles JSX down to React.createElement() calls.
    After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.
    These objects are React elements that describe what React should add to the real DOM on the HTML page.
    React reads these objects, interprets them, and uses them to construct the DOM elements and keep them up to date.
    SIDE NOTE:
              JSX can't be read by the DOM.
              EX:
                const variableName = (
                  <>React elements</>
                );
                document.getElementById("root").append(variableName);
              JSX needs to be rendered by React.
              EX:
                const variableName = (
                  <>React elements</>
                );
                ReactDOM.render(variableName, document.getElementById("root-element"));
  III. Naming Convention:
    1. Attributes:
      React uses camelCase instead of all lowercase when naming element attributes and event handlers.
      EX:
        "class" in HTML = "className" in React
        "onclick" in HTML = "onClick" in React
      Literals rules are also different in React when assigning a value to an attribbute.
      a. String Literals:
        Quotes are used to specify a number/string value.
          const variableName = (
            <starting-tag attribute="value"> content </closing-tags>
          );
      b. Template Literals:
        Curly braces are used to embed a boolean/array/object value or a function.
          const variableName = (
            <starting-tag attribute={argument}> content </closing-tags>
          );
        SIDE NOTE:
                  If a function is assigned, it should be anonymous.
                  EX:
                      attribute="functionName()" in HTML = attribute={FunctionName} in React
        Curly braces are also used to embed expressions in JSX.
          <starting-tag>
            content
            {expresion}
          </closing-tags>
    2. Functions:
      React uses PascalCase instead of camelCase when naming functions.
      EX:
        "functionName" in JavaScript = "FunctionName" in React
  IV. Props:
    React components can accept arbitrary inputs, called props (properties) object argument with data.
    1. Function Component:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      function FunctionName(props) {
        return (
          <>React elements {props.attribute}</>
        );
      }
      const variableName = (
        <FunctionName atribute="value" />
      );
      root.render(variableName);
    2. Class Component:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      class ClassName extends React.Component {
        render() {
          return (
            <>React elements {this.props.attribute}</>
          );
        }
      }
      root.render(<ClassName atribute="value" />);
    Props must never be modified. All React components must act like pure functions with respect to their props.
    With props, whenever the component is rendered into the DOM node, only a single instance of the component is executed. Therefore, when the component needs to be re-rendered over the time, state and lifecycle are preferred to use.
  V. State and Lifecycle:
    1. State:
      State is similar to props.
      While props is set up by ReactDOM, state is private/local and encapsulated.
      State is fully controlled by the component and is not accessible to any component other than the one that owns and sets it.
        const root = ReactDOM.createRoot(document.getElementById("root"));
        class ClassName extends React.Component {
          constructor(props) {
            super(props);
            this.state = {attribute: "value"};
          }
          render() {
            return (
              <>React elements {this.state.attribute}</>
            );
          }
        }
        root.render(<ClassName />);
    2. Lifecycle:
      Lifecycle methods are methods on the React component class that run when the component mounts or unmounts.
        const root = ReactDOM.createRoot(document.getElementById("root"));
        class ClassName extends React.Component {
          constructor(props) {
            super(props);
            this.state = {attribute: "value"};
          }
          componentDidMount() {
            action;
          }
          componentWillUnmount() {
            action;
          }
          render() {
            return (
              <>React elements {this.state.attribute}</>
            );
          }
        }
        root.render(<ClassName />);
      The "componentDidMount()" lifecycle method runs after the component output has been rendered to the DOM.
      The "componentWillUnmount()" lifecycle method runs after the component is ever removed from the DOM.
    3. State Update:
      State must not be modified directly. To update state:
        this.setState({attribute: "value"});
      State and props may be updated asynchronously. Therefore, you should not rely on their values for calculating the next state. Depending on the situation, update state with a function or an object:
        this.setState({attribute: "value"});
        or
        this.setState((state, props) => {
          attribute: new value derived from previous value which is retrieved by using "state.attribute"
        });
      When the "setState()" method is called, React merges the object you provide into the current state. If state includes multiple independent variables, they can be updated independently with separate "setState()" calls.
    SIDE NOTE:
              You can declare as many class properties as you need as long as they don't interfere the data flow.
              If any callback functions are used within the "render()" method, you need to bind all of them to the component class in the constructor in order to use them.
                constructor(props) {
                  super(props);
                  this.state = {attribute: "value"};
                  this.functionName = this.functionName.bind(this);
                }
              A component may choose to pass its state down as props to its child components. Any data derived from that state can only affect components “below” them in the tree. Neither parent nor child components can know if a certain component is stateful or stateless. Whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.
  VI. Conditional Rendering:
    React allows you to create distinct components that encapsulate behavior you need, then you can render only some of them depending on the state of your application.
    Conditional operators are used to create elements representing the current state and let React update the UI to match them.
    1. If-Else Statements:
      if (condition) {
        action;
      } else {
        action;
      }
    2. Inline If with Logical Operator:
      This is used as an expression embedded in JSX.
        <starting-tag>
          {
            condition &&
            expression
          }
        </closing-tags>        
      If the condition is true, the expression will be evaluated. If the condition is false, React will ignore and skip the expression.
    3. Inline If-Else with Ternary Operator:
      This is used as an expression embedded in JSX.
        <starting-tag>
          {
            condition ? trueExpression : falseExpression
          }
        </closing-tags>       
    4. Preventing Component from Rendering:
      In some cases, it is better to return "null" and hide the component than returning the output and rendering the component.
      Returning "null" from the "render()" method of the component does not affect the firing of the component’s lifecycle methods.
  VII. Lists and Keys:
    1. Lists:
      In React, transforming arrays into lists of elements is nearly identical.
        const arrayName = [element0, element1, element2];
        const listName = arrayName.map(element => {
          <starting-tag>
            {element}
          </closing-tags> 
        });
        const variableName = <starting-tag> {listName} </closing-tags>;
    2. Keys:
      A key is a special string attribute that needs to be given to each element when creating their list to give them a stable unique identity.
      Keys help React identify which elements have changed, are added, or are removed.
        const listName = arrayName.map(element => {
          <starting-tag key={id}>
            {element}
          </closing-tags> 
        });
      a. use element values:
        If it is a list of different numeric elements, you can use their own values as unique keys.
          const arrayName = [number0, number1, number2];
          const listName = arrayName.map(element => {
            <starting-tag key={element.toString()}>
              {element}
            </closing-tags> 
          });
      b. use element data:
        If it is a list of object elements, you can use IDs from your data as unique keys.
          const arrayName = [
            {id:value0, name:value1},
            {id:value0, name:value1},
            {id:value0, name:value1}
          ];
          const listName = arrayName.map(element => {
            <starting-tag key={element.id}>
              {element.name}
            </closing-tags> 
          });
      c. use indexes:
        When you don’t have stable IDs for rendered elements, you may use the element indexes as keys as a last resort.
          const arrayName = [element0, element1, element2];
          const listName = arrayName.map((element, index) => {
            <starting-tag key={index}>
              {element.text}
            </closing-tags> 
          });
        Using indexes for keys is not highly recommended if the order of elements may change. This can negatively impact performance and may cause issues with the component state.
      Keys used within a list should be unique among elements. However, they don't have to be globally unique. Different lists can use duplicate sets of keys.
      Keys only make sense in the context of the surrounding array. Therefore, they should be assigned to the list elements specifically inside the main array method call, not any where else.
      A good rule of thumb is that list elements inside the main array method call need keys.
      If you need to pass the keys to the children components, pass it explicitly as a props.
  VIII. Forms:
    HTML form elements work a bit differently from other DOM elements in React because form elements naturally keep some internal state.
    In HTML, form elements such as "<input>", "<textarea>", and "<select>" typically maintain their own state and update it based on user input.
    In React, mutable state is typically kept in the "state" property of components and only updated with the "setState()" method.
    You can combine these by making the React state the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input.
    1. Comtrolled Components:
      A controlled component is a form element whose value is controlled by React.
        class ClassName extends React.Component {
          constructor(props) {
            super(props);
            this.state = {value: ''};
            this.handleChange = this.handleChange.bind(this);
            this.handleSubmit = this.handleSubmit.bind(this);
          }

          handleChange(event) {
            this.setState({value: event.target.value});
          }

          handleSubmit(event) {
            alert('A name was submitted: ' + this.state.value);
            event.preventDefault();
          }

          render() {
            return ();
          }
        }
      a. input text:
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Name:
                <input type="text" value={this.state.value} onChange={this.handleChange} />
              </label>
              <input type="submit" value="Submit" />
            </form>
          );
        }
      b. textarea:
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Essay:
                <textarea value={this.state.value} onChange={this.handleChange} />
              </label>
              <input type="submit" value="Submit" />
            </form>
          );
        }
      c. select drop-down list:
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Pick your favorite flavor:
                <select value={this.state.value} onChange={this.handleChange}>
                  <option value="grapefruit">Grapefruit</option>
                  <option value="lime">Lime</option>
                  <option value="coconut">Coconut</option>
                  <option value="mango">Mango</option>
                </select>
              </label>
              <input type="submit" value="Submit" />
            </form>
          );
        }
        The "select" element can also accept multiple options by adding "multiple={true}" attribute.
      This makes it so that "<input type="text">", "<textarea>", and "<select>" elements work very similarly. They all accept a "value" attribute that can be used to implement a controlled component.
    2. Uncontrolled Components:

  IX. Lifting State Up:
    Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.
  X. Event Handling:
    https://reactjs.org/docs/handling-events.html
