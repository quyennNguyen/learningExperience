SOURCE: https://youtu.be/bMknfKXIFA8

WHAT IS REACT?
  React, or ReactJs, is a JavaScript library for building user interfaces and developing web applications.
  React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.
  I. How to add React to an HTML page?
    - add <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    - add <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  II. Declarative:
    React is declarative. 
    Being declarative means I can tell the computer WHAT to do and the computer can handle the details, while being imperative means I have to tell the computer HOW to do WHAT steps by steps.
  III. Composable and Reusable:
    Elements are the smallest building blocks of a Web page that describe what you want to see on the page. And, components are made of elements.
    Unlike browser DOM elements, React elements are plain JavaScript objects created and returned by JSX that represents DOM elements. And, React components are essentially functions that return React elements.
    Components let you split the UI into independent reusable pieces.

WHAT IS REACTDOM?
  ReactDOM is a global variable of the ReactDOM library.
  React DOM is used to render React components and take care of efficiently updating the DOM to match the React elements. It compares the elements and their children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.
  I. Rendering Elements:
    ReactDOM.render(
      <>React elements</>,
      document.getElementById("root-element")
    );
  II. Root Element:
    A root DOM node/container is required to mark the spot where React DOM should display its components on the HTML page. It will be managed by React DOM.
    To declare a root element:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
        <>React elements</>
      );    
    Web pages built with just React usually have a single root DOM node. If you are integrating React into an existing page, you may have as many isolated root DOM nodes as you like.
  III. React Components:
    To declare a React component:
    1. as a variable:
      const variableName = (
        <>React elements</>
      );
      ReactDOM.render(variableName, document.getElementById("root-element"));
    2. as a function component:
      function FunctionName() {
        return (
          <>React elements</>
        );
      }
      ReactDOM.render(<FunctionName />, document.getElementById("root-element"));
    3. as a class component:
      class ClassName extends React.Component {
        render() {
          return (
            <>React elements</>
          );
        }
      }
      ReactDOM.render(<ClassName />, document.getElementById("root-element"));
    All React elements must be nested in one single parent element/tag. Fragment tags "<></>" can be used as the parent tag.
    React elements are immutable, which means they, their children, and their attributes can't be changed. The only way to update the rendered element is to create a new element and re-render it.

WHAT IS JSX?
  JSX, stands for JavaScript XML, is a syntax extension to JavaScript, which produces React elements.
  JSX makes it easier to write HTML and JavaScript in one file.
  React is what defines JSX, so JSX needs to be used together with React.
  I. How to add JSX to an HTML page?
    1. Method 1:
        - add <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        - add <script src="script.js" type="text/babel"></script>
      This method may slow down your Website and isn't suitable for production.
    2. Method 2:
        - download Node.js
        - run npm init -y
        - run npm install babel-cli@6 babel-preset-react-app@3
        - create a "src" folder where the "script.js" file will locate
        - run npx babel --watch src --out-dir . --presets react-app/prod
      This method is the setup for a production-ready JSX preprocessor to convert all "script" tags automatically.
  II. Object Representation:
    Babel compiles JSX down to React.createElement() calls.
    After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.
    These objects are React elements that describe what React should add to the real DOM on the HTML page.
    React reads these objects, interprets them, and uses them to construct the DOM elements and keep them up to date.
    SIDE NOTE:
              JSX can't be read by the DOM.
              EX:
                const variableName = (
                  <>React elements</>
                );
                document.getElementById("root").append(variableName);
              JSX needs to be rendered by React.
              EX:
                const variableName = (
                  <>React elements</>
                );
                ReactDOM.render(variableName, document.getElementById("root-element"));
  III. Naming Convention:
    1. Attributes:
      React uses camelCase instead of all lowercase when naming element attributes and event handlers.
      EX:
        "class" in HTML = "className" in React
        "onclick" in HTML = "onClick" in React
      Literals rules are also different in React when assigning a value to an attribbute.
      a. String Literals:
        Quotes are used to specify a numeric or string value.
          const variableName = (
            <starting-tag attribute="value"> content </closing-tags>
          );
      b. Template Literals:
        Curly braces are used to embed a function or object value.
          const variableName = (
            <starting-tag attribute={argument}> content </closing-tags>
          );
        SIDE NOTE:
                  If a function is assigned, it should be anonymous.
                  EX:
                      attribute="functionName()" in HTML = attribute={FunctionName} in React
        Curly braces are also used to embed expressions in JSX.
          <starting-tag>
            content
            {expresion}
          </closing-tags>
    2. Functions:
      React uses PascalCase instead of camelCase when naming functions.
      EX:
        "functionName" in JavaScript = "FunctionName" in React
  IV. Props:
    React components can accept arbitrary inputs, called props (properties) object argument with data.
    1. Function Component:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      function FunctionName(props) {
        return (
          <>React elements {props.attribute}</>
        );
      }
      const variableName = (
        <FunctionName atribute="value" />
      );
      root.render(variableName);
    2. Class Component:
      const root = ReactDOM.createRoot(document.getElementById("root"));
      class ClassName extends React.Component {
        render() {
          return (
            <>React elements {this.props.attribute}</>
          );
        }
      }
      root.render(<ClassName atribute="value" />);
    Props must never be modified. All React components must act like pure functions with respect to their props.
    With props, whenever the component is rendered into the DOM node, only a single instance of the component is executed. Therefore, when the component needs to be re-rendered over the time, state and lifecycle are preferred to use.
  V. State and Lifecycle:
    1. State:
      State is similar to props.
      While props is set up by ReactDOM, state is private/local and encapsulated.
      State is fully controlled by the component and is not accessible to any component other than the one that owns and sets it.
        const root = ReactDOM.createRoot(document.getElementById("root"));
        class ClassName extends React.Component {
          constructor(props) {
            super(props);
            this.state = {attribute: "value"};
          }
          render() {
            return (
              <>React elements {this.state.attribute}</>
            );
          }
        }
        root.render(<ClassName />);
    2. Lifecycle:
      Lifecycle methods are methods on the React component class that run when the component mounts or unmounts.
        const root = ReactDOM.createRoot(document.getElementById("root"));
        class ClassName extends React.Component {
          constructor(props) {
            super(props);
            this.state = {attribute: "value"};
          }
          componentDidMount() {
            action;
          }
          componentWillUnmount() {
            action;
          }
          render() {
            return (
              <>React elements {this.state.attribute}</>
            );
          }
        }
        root.render(<ClassName />);
      The "componentDidMount()" lifecycle method runs after the component output has been rendered to the DOM.
      The "componentWillUnmount()" lifecycle method runs after the component is ever removed from the DOM.
    3. State Update:
      State must not be modified directly. To update state:
        this.setState({attribute: "value"});
      State and props may be updated asynchronously. Therefore, you should not rely on their values for calculating the next state. Depending on the situation, update state with a function or an object:
        this.setState({attribute: "value"});
        or
        this.setState((state, props) => {
          attribute: "value"
        });
      When the "setState()" method is called, React merges the object you provide into the current state. If state includes multiple independent variables, they can be updated independently with separate "setState()" calls.
    SIDE NOTE:
              You can declare as many class properties as you need as long as they don't interfere the data flow.
              If any callback functions are used within the "render()" method, you need to bind all of them to the component class in the constructor in order to use them.
                constructor(props) {
                  super(props);
                  this.state = {attribute: "value"};
                  this.functionName = this.functionName.bind(this);
                }
              A component may choose to pass its state down as props to its child components. Any data derived from that state can only affect components “below” them in the tree. Neither parent nor child components can know if a certain component is stateful or stateless. Whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.
  VI. Conditional Rendering:
    In React, you can create distinct components that encapsulate behavior you need, then you can render only some of them depending on the state of your application.
    Conditional operators are used to create elements representing the current state and let React update the UI to match them.
    1. If-Else Statements:
      if (condition) {
        action;
      } else {
        action;
      }
    2. Inline If with Logical Operator:
        {
          condition &&
          expression
        }
      If the condition is true, the expression will be evaluated. If the condition is false, React will ignore and skip the expression.
    3. Inline If-Else with Ternary Operator:
      {
        condition ? trueExpression : falseExpression
      }
    4. Preventing Component from Rendering:
      In some cases, it is better to return "null" and hide the component than returning the output and rendering the component.
      Returning "null" from the "render()" method of the component does not affect the firing of the component’s lifecycle methods.
  VII. Event Handling:
    https://reactjs.org/docs/handling-events.html