WHAT IS JAVASCRIPT?
    JavaScript is the default scripting language in HTML and of the key programming languages of the Web.
    While HTML defines the content of the Web page and CSS specifies the layout of the Web page, JavaScript programs the behavior of the Web page.
    File extension: .js

HOW TO ADD JAVASCRIPT TO HTML?
    1. Within the HTML page:
        Script can be specified between <script> tags, that are placed either at the end of <head> or at the end of <body>.
    2. In an external file:
        There are many advantages of having script in a separate file.
        To implement the external script, in the src attribute of the <script> tag of the HTML page, place the reference/path of the external script file.
        JavaScript files have the file extension .js
    SIDE NOTE:
                Several <script> tags can be used to add several script files to one HTML page.

WHAT IS A JAVASCRIPT PROGRAM?
    A computer program is a list of instructions to be executed by the computer.
    In a programming language, these instructions are called statements.
    A JavaScript program is a list of programming statements.
    JavaScript statements:
        -are executed one by one, in the same order as they are written, by the Web browser in HTML.
        -are composed of: values, operators, expressions, keywords/reserved words, comments,...
        -can be grouped together in a code block.
    A code block is used to define statements to be executed together within a braces {} pair.
    The set of rules of how programs in that language are constructed is its syntax.
    JavaScript syntax defines two types of values:
        literals
        variables

GENERAL SYNTAX:
    A JavaScript expression is a combination of variables, operators, and values, that computes to a value. The computation is called an evaluation.
    In a programming language, variables are containers for storing data values.
    I. Keywords:
        Keywords are used to specify actions to be performed, for example, to declare a variable.
        1. var:
            Keyword "var" doesn't have block scope but has function scope and global scope.
            Variables defined with "var" can be used before it is declared, as long as it is assigned with a value before action is taken.
                variableName = value;
                var variableName;
            Variables defined with "var" doesn't have to be declared and initialized all at once.
            Variables defined with "var" can be redeclared and reassigned.
            With "var", the value can be changed.
            However, "var" is outdated and not recommended to use.
        2. let:
            Keyword "let" has block scope, function scope, and global scope.
            Variables defined with "let" can't be used until it is declared.
                let variableName;
                variableName = value;
            Variables defined with "let" doesn't have to be declared and initialized all at once.
            Variables defined with "let" can't be redeclared but can be reassigned.
            With "let", the value can be changed.
        3. const:
            Keyword "const" has block scope, function scope, and global scope.
            Variables defined with "const" can't be used until it is declared.
                const variableName = value;
            Variables defined with "const" have to be declared and initialized all at once.
            Variables defined with "const" can't be redeclared and reassigned.
            Keyword "const" doesn't define a constant value but defines a constant reference to a value, as for an array, an object, a function, a RegExp. Therefore, in a sense, the value can't be changed.
    II. Identifiers:
        Identifiers are used to name, or to create a reference for, variables and functions.
        General rule for JavaScript identifiers:
            -can contain letters, digits, underscores (_), dollar signs ($).
            -must not begin with a digit.
            -are case sensitive.
            -must not use reserved words.
            -should use camelCase naming style.
    III. Operators:
        An operation consists of operand(s) and operator(s).
        1. Arithmetic Operators:
            Arithmetic operators (addition+ substraction- multiplication* division/ modulus% increment++ decrement-- exponentiation**) are used to compute values.
            SIDE NOTE:
                        The exponentiation operation x**y produces the same result as the method Math.pow(x,y).
                        The operator precedence in JavaScript arithmetic is the same as in school mathematics.
            Full reference: https://www.w3schools.com/js/js_arithmetic.asp
        2. String Operator:
            Concatenation operator (+) is used to concatenate strings.
            If the operation is performed between a number and a string, it will return a string.
            SIDE NOTE:
                        The computer evaluates expressions from left to right until it returns the final string.
        3. Comparison, Logical, and Conditional Operators:
            Comparison and logical operators are used to test for true or false so as to take action depending on the results.
            Comparison operators (== === != !== > >= < <=) are used in conditional statements to determine equality or difference between values.
            Logical operators (&& || !) are used to determine the logic between values.
            Conditional operator, or Ternary operator, is used to assign a value to a variable based on some conditions.
                let variableName = (condition) ? value1 : value2;
            Full reference: https://www.w3schools.com/js/js_comparisons.asp
        4. Type Operator:
            TypeOf operator (typeof) is used to return the data type of a variable or an expression.
                typeof a number returns number
                typeof a string returns string
                typeof a boolean returns boolean
                typeof an array returns object
                typeof an object returns object
                typeof a function returns function
                typeof a null returns object
                typeof an undefined returns undefined
                typeof a NaN returns number
            Full reference: https://www.w3schools.com/js/js_type_conversion.asp
        5. Bitwise Operators:
            Full reference: https://www.w3schools.com/js/js_bitwise.asp
        6. Assignment Operators:
            Assignment operator (= += -= *= /= %= **=) is used to assign a value to a variable.
            Full reference: https://www.w3schools.com/js/js_assignment.asp
        7. Unary Operator:
            Unary operator (+) is used to convert another date type to a number.
    IV. Values & Data Types:
        JavaScript data types are dynamic because the same variable can hold different data types.
        1. Primitive Data Types:
            number
            string
            boolean
            undefined
            null
            symbol
            a. Data types that can have values:
                number
                string
                boolean
                object
                function
            b. Data types that don't have values:
                undefined
                null
            c. Complex data types:
                object
                function                
        2. Object Data Types:
            Object
            Number
            String
            Boolean
            Array
            Date
            RegEX
        3. Undefined:
            This data type represents a variable is initialized but isn't assigned to any value or a function returns undefined if its variable doesn't return any value.
        4. Null:
            This data type represents an absence of value.
        5. No Keyword:
            If a variable is assigned with a value and isn't declared with any keyword, it is defined as "undeclared" and will automatically have a global scope.
        6. No Value:
            If a variable is declared with a keyword but isn't assigned with a value, both of its value and data type will be "undefined".
    V. Scope:
        Scope determines the accessibility, or visibility, of variables, objects, functions from different parts of the program.
        1. Block Scope:
            Variables that have a block scope when declared within a code block can only be accessed from inside the code block and will be independent from outside the code block.
        2. Function Scope:
            Variables that are declared within a function will be local to the function; in other words, they are created when the function starts and deleted when the function is completed; and, will have a function scope.
            Variables that have a function scope can only be accessed from inside the function.
        3. Global Scope:
            Variables that are declared outside any function will have a global scope.
            Variables that have a global scope can be accessed from anywhere in the program.
    VI. Hoisting:
        Hoisting is JavaScript's default behavior of moving all declarations to the top of the scope.
        JavaScript hoists only declarations not initializations.

WHAT IS A JAVASCRIPT FUNCTION?
    A function is a code block designed to perform a particular task and is executed to compute a return value when called/invoked/run.
    to declare a function:
        1. with "function" as a keyword:
            function functionName(parameter1, parameter2, parameter3) {
                action to be executed;
            }
            let variableName = functionName(argument1, argument2, argument3);
        2. with "function()" as a method:
            let functionName = function(parameter1, parameter2, parameter3) {
                action to be executed;
            }
            let variableName = functionName(argument1, argument2, argument3);
        3. with arrow function:
                let functionName = (parameter1, parameter2, parameter3) => {
                    action to be executed;
                }
                let variableName = functionName(argument1, argument2, argument3);
            If the task includes only one statement and returns a value:
                let functionName = (parameter1, parameter2, parameter3) => action to be executed to return a value;
                let variableName = functionName(argument1, argument2, argument3);
            If the function has only one parameter:
                let functionName = parameter => {
                    action to be executed;
                }
                let variableName = functionName(argument);
    SIDE NOTE:
                A parameter is the value defined in the function definition when the function is declared.
                An argument is the value passed to, or received by, the function when the function is called/invoked/run.
                All parameters and arguments are optional.
                The parentheses () works as an operator that specifies the result of the function (to be returned). Without the parentheses (), the call will return the function definition.
                A method is fundamentally a property with a function definition.

WHAT IS A JAVASCRIPT SYMBOL?
    Symbol is a primitive data type.
    I. Constructor:
        A Symbol object is created when the Symbol(key) constructor is called.
        The returned value is unique.
    II. Properties:
    III. Methods:
        1. Static Methods:
            a. to look for a symbol in the global symbol registry:
                    const variableName = Symbol.for(targeted symbol);
                If the targeted symbol is found, it will return the same value of the targeted symbol. If not found, a new symbol object of the targeted value will be created.
            Symbol.keyFor()
        2. Instance Methods:
            toString()
            valueOf()
            @@ToPrimitive()

WHAT ARE JAVASCRIPT NUMBERS?
    Number is a primitive data type.
    Numbers are stored as double precision floating point numbers written with or without decimals and in 64 bits, where the fraction is 52 bits (from 0 to 51), the exponent is 11 bits (from 52 to 62), and the sign is 1 bit (63).
    I. Scientific Notation, or Exponential Notation,:
        Extra large or extra small numbers can be written in special notation.
        EX:
            123456789 = 1.23456789e+8
            0.00123456789 = 1.23456789e-3
    II. Number Precision (before round up):
        Integers can store up to 15 digits of precision.
        Decimals can store up to 17 places of precision.
        Floating point arithmetic isn't always accurate.
    III. Numberic Bases:
        By default, JavaScript interprets numbers as base 10 decimals.
        A number constant will be interpreted as a hexadecimal if it is preceded by Ox.
        A number might be interpreted as an octal if it is written with a leading zero.
        There are different numeric bases:
            base 36: hexatrigesimal
            base 32: duotrigesimal
            base 16: hexadecimal
            base 12: duodecimal
            base 8: octal
            base 2: binary
        to convert a number (base 10 decimal) to another base:
            let numberName2 = numberName1.toString(base);
    IV. Reserved words:
        NaN: is Not a Number, typeof NaN is number.
        Infinity, or -Infinity,: is returned when a calculated number is beyond the largest possible number, typeof Infinity is number.
    V. Properties:
        Number properties belongs to the Number object wrapper called Number.
        1. to return the largest possible number:
            let numberName = Number.MAX_VALUE;
        2. to return the smallest possible number:
            let numberName = Number.MIN_VALUE;
        3. to represent Infinity, or -Infinity, that is returned on overflow,:
            let numberName = Number.POSITIVE_INFINITY;
            let numberName = Number.NEGATIVE_INFINITY;
        5. to specify an illegal number:
            let numberName = Number.NaN;
    VI. Methods:
        1. to return a number as a string:
            let stringName = numberName.toString();
        2. to return a number as a number:
                let numberName2 = numberName1.valueOf();
            Ultimately, this can convert a Number object to a primitive number.
        3. to return a number in scientific notation, or exponential notation,:
            let stringName = numberName.toExponential(decimal),
            The number might be rounded if neccessary.
            The "decimal" parameter specifies the number of characters behind the decimal point. It is optional and can't be negative. If the "decimal" parameter is omitted, the number won't be rounded.
        4. to round a number:
            a. let stringName = numberName.toFixed(decimal);
                The "decimal" parameter specifies the number of characters behind the decimal point. It is optional and can't be negative. If the "decimal" parameter is omitted, it will be specified as 0, that means the number is rounded as a whole number.
            b. let stringName = numberName.toPrecision(digit);
                The "digit" parameter specifies the number of digits, or the length of the number. It is optional and can't be zero or negative. If the "digit" parameter is omitted, the number remains unchanged.
        5. to check if a value is a number:
            let booleanName = isNaN(value);
    VII. JavaScript Global Methods (that returns numbers):
        1. to convert another data type to a number:
            let numberName = Number(value);
            The "value" parameter can be, for example,:
                numeric string -> number
                empty string"" -> 0
                true -> 1
                false -> 0
            If the "value" parameter can't be converted to a number, it will return NaN.
            SIDE NOTE:
                        There is a similarity between Number() method and unary operator.
                            Number() method:
                                let numberName = Number(value);
                            Unary operator:
                                let numberName = + value;
        2. to parse a string to a number:
            a. let numberName = parseInt("text");
                This returns an integer.
                Spaces are allowed, and only the first number is returned.
                If the "text" parameter can't be converted to a number, it will return NaN.
            b. let numberName = parseFloat("text");
                This returns a float.
                Spaces are allowed, and only the first number is returned.
                If the "text" parameter can't be converted to a number, it will return NaN.
    Full list of number reference: https://www.w3schools.com/jsref/jsref_obj_number.asp
    SIDE NOTE:
                In some programming languages, primitive values can't have properties or methods because they are not objects. On the other hand, JavaScript treats primitive values as objects when they are executed using properties or methods.
                Try to avoid using "String", "Number", "Boolean", or "Array" object to declare a variable, as it will complicate the code and slow down the execution speed.

WHAT IS A JAVASCRIPT STRING?
    String is a primitive data type.
    Strings are text values containing zero or more characters written within single (' ') or double (" ") quotes.
    I. Template Literals, or String Template, or Back-Tics Syntax:
        Template literals:
            - use back-ticks (` `) instead of single quotes (' ') or double quotes (" ") to define a string.
            - allows to use either single quotes (' ') or double quotes (" ") or both inside a string.
            - allows multiline strings.
            - allows string interpolation, which is an easy way to interpolate variables, expressions, or HTML templates into strings; in other words, an efficient way of string concatenation.
                variable substitution: ${variableName}
                expression substitution: ${expression}
    II. Escape Character:
        The backslash (\) escape character is used to avoid misunderstanding of special characters in a string.
            \character
            EX: 
                \' to insert a single quote
                \" to insert a double quote
                \\ to insert a backslash
    III. Regular Expressions
        A regular expression is a sequence of characters, like strings written without quotes, that forms a search pattern that can be used for text search and text replacement operations.
            /pattern/
        1. Properties:
            a. Modifiers:
                This can be used to perform case-insensitive matching, global match, or multiline matching,...
                    /pattern/modifier   
                /pattern/i: for case-insensitive matching
                /pattern/g: for global match
                /pattern/m: for multiline matching
            b. Brackets:
                This can be used to find a range of characters.
                    /[character]/modifier
                /[xyz]/g: to find all characters specified in the brackets
                /[x-y]/g: to find all digits specified from x to y
                /(x|y)/g: to find all the alternatives separated with the pipe
            c. Metacharacters:
                This specifies characters with a special meaning.
                    /\metacharacter/modifier
                /\d/g: to find all the digits
                /\s/g: to find all whitespaces
                /\bword/i: to find the index of the character before the specified word
                /word\b/i: to find the index of the specified word
                /\uxxxx/g: to find all the Unicode characters specified by the hexadecimal number "xxxx"
            d. Quantifiers:
                This defines quantities.
                    /quantifier/modifier
                Full reference: https://www.w3schools.com/js/js_regexp.asp
        2. Methods:
            a. regular expression as an argument:
                a.1 stringName.search(regular expression);
                a.2 stringName.replace(regular expression);
                a.3 stringName.match(regular expression);
            b. regular expression as an object:
                The RegExp object is a regular expression object with predefined properties and methods.
                b.1 to check if there is any match of a specified pattern in a string:
                    const variableName = /pattern/;
                    let booleanName = variableName.test("text");
                b.2 to return the match of a specified pattern in a string:
                        const variableName = /pattern/;
                        const objectname = variableName.exec("text");
                    If no match is found, it will return an empty object (null).
        Full reference: https://www.w3schools.com/jsref/jsref_obj_regexp.asp
    IV. Index:
        In JavaScript, string indexes are zero-based, that means they start with O, then 1, then 2,...
    V. Properties:
        to return the length of a string:
            let numberName = stringName.length;
    VI. Methods:
        Strings are immutable, that means they can't be affected, changed or replaced.
        //methods return a number
        1. to return the index of a value in a string:
            a. let numberName = stringName.indexOf("text", position);
                This returns the index of the first occurrence.
                If the "text" parameter is not found, it will return -1.
                The "position" parameter is optional.
                If the "position" parameter is positive, the search starts from the specified position to the end of the string.
                If the "position" parameter is negative, the search starts from the specified position to the beginning of the string.
            b. let numberName = stringName.lastIndexOf("text", position);
                This returns the index of the last occurrence.
                If the "text" parameter is not found, it will return -1.
                The "position" parameter is optional.
                The "position" parameter can't be negative, and the search starts from the specified position to the beginning of the string.
            c. let numberName = stringName.search("text");
                This returns the index of the first occurrence.
                If the "text" parameter is not found, it will return -1.
                SIDE NOTE:
                            The difference between indexOf("text") and search("text") are:
                                indexOf("text") can't take regular expressions and flags.
                                search("text") can take only one parameter.
        //methods return a string
        2. to extract a part of the string:
            a. let stringName2 = stringName1.slice(start, end);
                If the "start" and "end" parameters are positive, the extraction counts from the beginning of the string, and the "end" position is not included.
                If the "start" and "end" parameters are negative, the extraction counts from the end of the string, and the "start" position is not included.
                If only one parameter is specified, the extraction counts from the specified position to the rest of the string. If the parameter is negative, the specified position is not included.
            b. let stringName2 = stringName1.substring(start, end);
                If the "start" and "end" parameters are positive, the extraction counts from the beginning of the string, and the "end" position is not included.
                If only one parameter is specified, the extraction counts from the specified position to the rest of the string.
                If the parameter is negative, the position is specified as 0.
            c. let stringName2 = stringName1.substr(start, length);
                If the "start" parameter is positive, the extraction counts from the beginning of the string.
                If the "start" parameter is negative, the extraction counts from the end of the string.
                If only one parameter is specified, the extraction counts from the specified position to the rest of the string. If the parameter is negative, the specified position is not included.
                The "length" parameter can't be zero or negative.
        3. to extract a character at a specified position of a string:
            a. let charName = stringName.charAt(position);
                The "position" parameter can't be negative.
                SIDE NOTE:
                            Property Access: stringName[position]
                            In some cases, stringName.charAt(position) and stringName[position] might return the same result, but there might be some differences/issues.
            b. let codeName = stringName.charCodeAt(position);
                This returns the unicode (UTF-16 code - an integer from 0 to 65535) of the character.
                The "position" parameter can't be negative.
        4. to replace a value in a string with another value:
            let stringName2 = stringName1.replace("text1", "text2");
        5. to add one or more values to a string:
            let stringName2 = stringName1.concat(value1, value2);
        6. to convert a string to an uppercase or a lowercase:
            let stringName2 = stringName1.toUpperCase();
            let stringName2 = stringName1.toLowerCase();
        7. to remove whitespaces on the sides of a string:
            a. let stringName2 = stringName1.trim();
                This removes on both sides of a string.
            b. let stringName2 = stringName1.trimStart();
                This removes at the beginning of a string.
            c. let stringName2 = stringName1.trimEnd();
                This removes at the end of a string.
        8. to pad another string to a string:
            a. let stringName2 = stringName1.padStart(length, "text");
                This pads at the beginning of a string.
                The "length" parameter can't be zero or negative.
            b. let stringName2 = stringName1.padEnd(length, "text");
                This pads at the end of a string.
                The "length" parameter can't be zero or negative.
        //methods return a boolean
        9. to check whether a string contains/starts with/ends with a value and return a boolean value:
            a. stringName.includes("text", position);
                The "position" parameter is optional and can't be negative.
                If the "position" parameter is omitted, it will check the first occurrence.
                If the "position" parameter is specified, the check starts from the specified position to the end of the string.
            b. stringName.startsWith("text", position);
                The "position" parameter is optional and can't be negative.
                If the "position" parameter is specified, the check starts from the specified position.
            c. stringName.endsWith("text", length);
                The "length" parameter is optional and can't be zero or negative.
                If the "length" parameter is specified, it will check within the specified length counting from the beginning of the string.
        //methods return an array
        10. to search a string for a match:
            let stringName = "text1";
            const arrayName = stringName.match("text2");
            All the matches will be returned as an array.
            If no match is found, it will return "null".
        11. to convert a string to an array:
            let stringName = "text";
            const arrayName = stringName.split("separator");
            If the "separator" parameter is omitted, it will assign the whole string to the item at index[0] of the array.
            If the "separator" parameter is "", it will return an array of every single characters in the string.
            The separator can be whitespaces (" "), commas (","), pipes ("|"),..., then it will return an array of substrings separated by the specified separator.
    VII. JavaScript Global Methods (that returns strings):
        to convert another data type to a string:
            let stringName = String(value);
        The "value" parameter can be, for example,:
                number -> numeric string
                true -> "true"
                false -> "false"
    Full list of string reference: https://www.w3schools.com/jsref/jsref_obj_string.asp
    SIDE NOTE:
                In some programming languages, primitive values can't have properties or methods because they are not objects. On the other hand, JavaScript treats primitive values as objects when they are executed using properties or methods.
                Try to avoid using "String", "Number", "Boolean", or "Array" object to declare a variable, as it will complicate the code and slow down the execution speed.

WHAT ARE JAVASCRIPT BOOLEANS?
    Boolean is a primitive data type.
    A boolean represents one of two values: true or false / yes or no / on or off.
    I. Properties:
        Everything with a value is true.
        Everything without a value is false.
            Boolean(0) = false
            Boolean("") = false
            Boolean(undefined) = false
            Boolean(null) = false
            Boolean(NaN) = false
    II. Methods:
        to determine if a variable or an expression is true or false:
            let booleanName = Boolean(variable/expression);
        or in a simplier way:
            let booleanName = variable/expression;
    Full list of boolean reference: https://www.w3schools.com/jsref/jsref_obj_boolean.asp
    SIDE NOTE:
                In some programming languages, primitive values can't have properties or methods because they are not objects. On the other hand, JavaScript treats primitive values as objects when they are executed using properties or methods.
                Try to avoid using "String", "Number", "Boolean", or "Array" object to declare a variable, as it will complicate the code and slow down the execution speed.

WHAT IS A JAVASCRIPT ARRAY?
    Array is a non-primitive data type.
    Arrays are a special type of objects.
    Arrays are stored as a list of values that can be of any types of data, numbers, strings, arrays, objects, functions,... They can hold more than one value under one variable, and  the values can be accessed by referring to the associated index numbers.
    to declare an array:
        const arrayName = [item0, item1, item2];
    or:
        const arrayName = [];
        arrayName[0] = value0;
        arrayName[1] = value1;
        arrayName[2] = value2;
    I. Index:
        In some programming languages, arrays with named indexes are called associative arrays, or hashes.
        In JavaScript, array indexes are numbered and zero-based, that means they start with O, then 1, then 2,...
    II. Properties:
        1. to return the length of an array, which is the number of array elements,:
            let numberName = arrayName.length;
        2. to access the whole array:
            arrayName
        3. to access an array element:
            arrayName[index]
        4. to change the value of an array element:
            arrayName[index] = newValue;
        5. to append an element to an array:
            arrayName[arrayName.length] = newValue;
            Items at indexes that aren't assigned with any value will be assigned with "undefined".
        6. to delete an array element:
            delete arrayName[index];
            Instead of completely removing the array element like arrayName.pop() or arrayName.shift(), this leaves an "undefined" hole at the specified index.
        7. to display an array of object:
            const arrayName = [object1, object2, object3];
            console.log(JSON.stringify(arrayName));
    III. Methods:
        //methods return a number
        1. to find the index of an array element:
            a. let numberName = arrayName.indexOf(elementValue, start);
                This returns the index of the first occurrence.
                If the element is not found, it will return -1.
                The "start" parameter is optional.
                If the "start" parameter is positive, the search starts from the specified position, counted from the beginning of the array, to the end of the array.
                If the "start" parameter is negative, the search starts from the specified position, counted from the end of the array, to the end of the array.
            b. let numberName = arrayName.lastIndexOf(elementValue, start);
                This returns the index of the last occurrence.
                If the element is not found, it will return -1.
                The "start" parameter is optional.
                If the "start" parameter is positive, the search starts from the specified position, counted from the beginning of the array, to the end of the array.
                If the "start" parameter is negative, the search starts from the specified position, counted from the end of the array, to the beginning of the array.
        //methods return a string
        2. to convert an array to a string:
            a. let stringName = arrayName.toString();
                This returns a string of array values separated by commas.
                Because toString() is of default methods of an Array object, using either arrayName or arrayName.toString() will return the same result.
            b. let stringName = arrayName.join("separator");
                The "separator" parameter is optional.
                If the "separator" parameter is omitted, it will behave like arrayName.toString().
                If the "separator" parameter is specified, it will return a string of array values separated by specified separator.
                The separator can be whitespaces (" "), commas (","), pipes ("|"),...
        //methods return a boolean
        3. to check whether an element is present in an array:
            let variableName = arrayName.includes(elementValue);
        //methods return an array or an array-related value
        4. to add/remove an element to/from an array:
            4.1 pushing and popping:
                a. let numberName = arrayName.push(value);
                    This pushes a new element into the end of the array, and returns the new length of the array.
                b. let variableName = arrayName.pop();
                    This pops the last element out of the array, and returns the element that is popped out.
            4.2 unshifting and shifting:
                a. let numberName = arrayName.unshift(value);
                    This pushes a new element into the beginning of the array, and returns the new length of the array.
                    The old indexes have to shift according to the added element.
                b. let variableName = arrayName.shift();
                    This pops the first element out of the array, and returns the element that is shifted out.
                    The old indexes have to shift according to the removed element.
            4.3 splicing:
                const arrayName2 = arrayName1.splice(whereToAdd, howManyRemoved, value1, value2);
                This can be used to either add or remove one or more elements, and returns an array of removed elements.
                The "whereToAdd" parameter specifies the index where new elements should be added. It can't be negative.
                The "howManyRemoved" parameter specifies how many elements should be removed. It can't be negative.
                The "value" parameters are optional. If the "value" parameters are omitted, no element is added. If the "value" parameters are specified, more than one element can be added.
        5. to extract a part of an array:
            const arrayName2 = arrayName1.slice(start, end);
            If the "start" and "end" parameters are positive, the extraction counts from the beginning of the array, and the "end" position is not included.
            If the "start" and "end" parameters are negative, the extraction counts from the end of the array, and the "end" position is not included.
            If only one parameter is specified, the extraction counts from the specified position to the rest of the array.
        6. to merge, or concatenate, another array to an array:
            const arrayName2 = arrayName1.concat(value1, value2);
            This can concatenate more than one array to an array.
            This doesn't affect the existing arrays and always returns a new array.
            SIDE NOTE:
                        This method can concatenate other data types like numbers, strings,... to the array.
        7. to sort an array:
            7.1 string sort:
                a. in ascending order:
                    arrayName.sort();
                    This sorts the array alphabetically.
                b. in descending order:
                    arrayName.reverse();
                    This reverses the array.
                    combining
                        arrayName.sort(); 
                        arrayName.reverse();
                    or
                        arrayName.sort().reverse();
                    This sorts the array reverrse-alphabetically.
            7.2 numeric sort:
                a. alphabetically:
                    arrayName.sort();
                b. numerically:
                    A compare function is used to define an alternative numeric sort order.
                    b.1 in ascending order:
                        arrayName.sort(
                            function(a, b) {
                                return a - b;
                            }
                        );
                        If it returns negative, "a" < "b", so "a" is sorted before "b".
                        If it returns zero, "a" = "b", so no changes are made.
                        If it returns positive, "a" > "b", so "b" is sorted before "a".
                    b.2 in descending order:
                        arrayName.sort(
                            function(a, b) {
                                return b - a;
                            }
                        );
                        If it returns negative, "a" > "b", so "a" is sorted before "b".
                        If it returns zero, "a" = "b", so no changes are made.
                        If it returns positive, "a" < "b", so "b" is sorted before "a".
                c. randomly:
                        arrayName.sort(
                            function() {
                                return 0.5 - Math.random();
                            }
                        );
                    A better way is to use the Fisher Yates method:
                        const arrayName = [item0, item1, item2];
                        for (let i = arrayName.length - 1; i > 0; i--) {
                            let j = Math.floor(Math.random() * i);
                            let k = points[i];
                            points[i] = points[j];
                            points[j] = k;
                        }
            7.3 object sort:
                const arrayName = [
                    {stringName:"stringValue", numberName:numberValue},
                    {stringName:"stringValue", numberName:numberValue},
                    {stringName:"stringValue", numberName:numberValue}
                ];
                a. in ascending order:
                    a.1 comparing properties with string values:
                        arrayName.sort(
                            function(a, b) {
                                let x = a.stringName.toLowerCase();
                                let y = b.stringName.toLowerCase();
                                if (x < y) {
                                    return -1;
                                }
                                if (x > y) {
                                    return 1;
                                }
                                return 0;
                            }
                        );
                    a.2 comparing properties with number values:
                        arrayName.sort(
                            function(a, b) {
                                return a.numberName - b.numberName;
                            }
                        );
                b. in descending order:
                    b.1 comparing properties with string values:
                        arrayName.sort(
                            function(a, b) {
                                let x = a.stringName.toLowerCase();
                                let y = b.stringName.toLowerCase();
                                if (x > y) {
                                    return -1;
                                }
                                if (x < y) {
                                    return 1;
                                }
                                return 0;
                            }
                        );
                    b.2 comparing properties with number values:
                        arrayName.sort(
                            function(a, b) {
                                return b.numberName - a.numberName;
                            }
                        );
            7.4 to find the lowest/highest value in an array:
                a. sorting in ascending order:
                    let lowestValue = arrayName[0];
                    let highestValue = arrayName[arrayName.length-1];
                b. sorting in descending order:
                    let highestValue = arrayName[0];
                    let lowestValue = arrayName[arrayName.length-1];
                c. using Math object:
                    This only works with number values.
                    c.1 to find the lowest:
                        const arrayName = [item0, item1, item2];
                        let lowestValue = Math.min(item0, item1, item2);
                        This can find the lowest value in the list, but can't accept array parameter.
                        let lowestValue = Math.min.apply(null, arrayName);
                        This can find the lowest value in the array, but can only accept array parameter.
                    c.2 to find the highest:
                        const arrayName = [item0, item1, item2];
                        let highestValue = Math.max(item0, item1, item2);
                        This can find the highest value in the list, but can't accept array parameter.
                        let highestValue = Math.max.apply(null, arrayName);
                        This can find the highest value in the array, but can only accept array parameter.
        //array iteration
        8. to operate a function on every array element:
            A callback function (a higher-order function) is a function called in an array iteration to perform a task on every array element. 
                function functionName(total, value, index, array) {
                    action to be executed;
                }
            It can take up to four parameters "total", "value", "index", and/or "array" depending on the functionality.
                -"total": is the total/the initial value/the previously returned value
                -"value": is the item's value
                -"index": is the item's index
                -"array": is the array itself
            The parameter names are "reserved" for this purpose.
            a. arrayName.forEach(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                }
                This method itself doesn't return any value.
            b. const arrayName2 = arrayName1.map(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns a new array of values returned from the task execution.
                The "value" parameter is required.
            c. const arrayName2 = arrayName1.filter(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns a new array of values returned from only passing some sort of conditions.
            d. let variableName = arrayName.every(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns a boolean value of whether all of the array elements pass some sort of conditions.
            e. let variableName = arrayName.some(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns a boolean value of whether some (at least 1) of the array elements pass some sort of conditions.
            f. let variableName = arrayName.find(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns the value of the first array element that passes some sort of conditions.
            g. let variableName = arrayName.findIndex(functionName);
                function functionName(value, index, array) {
                    action to be executed;
                    return result;
                }
                This method returns the index of the first array element that passes some sort of conditions.
            h. 
                h.1 to operate from left to right:
                    let variableName = arrayName.reduce(functionName, initialValue);
                h.2 to operate from right to left:
                    let variableName = arrayName.reduceRight(functionName, initialValue);
                function functionName(total, value, index, array) {
                    action to be executed;
                    return result;
                }
                This method takes the array and reduces it to a single value, but doesn't affect the original array.
                The "initialValue" parameter is optional. If it is omitted, the initial value of the "total" parameter is 0. If it is specified, the initial value of the "total" parameter is the specified value.
        //special array methods
        9. to return an array from any object that is either iterable or with a length property:
            const arrayName = Array.from(value);
        10. to return an Array Iterator Object containing all the array indexes:
            const arrayName = [item0, item1, item2];
            const variableName = arrayName.keys();
            let text = "";
            for (let x of variableName) {
                text += x + "<br>";
            }
        11. to return an Array Iterator Object containing all the array index/value pairs:
            const arrayName = [item0, item1, item2];
            const variableName = arrayName.entries();
            let text = "";
            for (let x of variableName) {
                text += x + "<br>";
            }
    Full list of array reference: https://www.w3schools.com/jsref/jsref_obj_array.asp
    SIDE NOTE:
                While arrays use numbers, or numbered indexes, to access their elements, objects use names, or named indexes, to access their memebers. Therefore, although typeof array is object, it is still best described as array.
                Try to avoid using "String", "Number", "Boolean", or "Array" object to declare a variable, as it will complicate the code and slow down the execution speed.

WHAT IS A JAVASCRIPT OBJECT?
    Object is a non-primitive data type.
    An object may have:
        - properties, or attributes, that represent the characteristic of the object
        - methods, or functions, that represent the behavior/action of the object
    Many objects can have the same properties and methods, but the property values might differ, and the methods might perform differently.
    to declare an object:
        const objectName = {name0:value0, name1:value1, name2:value2};
    I. Properties:
        1. to define an object property:
            propertyName:propertyValue
        2. to access an object method:
            1. with dot notation:
                objectName.propertyName
            2. with bracket notation:
                objectName["propertyName"]
        3. to add a new property:
            objectName.propertyName = propertyValue;
    II. Methods:
        1. to define an object method:
            methodName:function() {
                action to be executed;
            }
        2. to access an object method:
            objectName.methodName()
    III. Date Object:
        The Date object lets you work with date and time.
            const variableName = new Date();
        This returns the current date and time according to the Web browser's time zone; in other words, the result might vary because the computer date is relative to your time zone.
        1. Numeric Date Input:
                const variableName = new Date(year, month, date, hour, minute, second, millisecond);
            The constructor can take up to 7 parameters. 
            The parameters are optional. If the parameters are specified, it will return the date and time as specified. 
            The "month" parameter is specified from 0 to 11.
            The "date" parameter is specified from 1 to 31.
            The "hour" parameter is specified from 0 to 23.
            The "minute" parameter is specified from 0 to 59.
            The "second" parameter is specified from 0 to 59.
            The "millisecond" parameter is specified from 0 to 999.
            SIDE NOTE:
                        In case of weekdays, the "day" parameter is specified from 0 to 6, where 0 is Sunday and 6 is Saturday.
            Specifying the parameters out of their "normal" range will not result in error but will add/deduct the overflow to the next/previous period of time.
        2. String Date Input:
                const variableName = new Date("date string");
            The constructor can also take date string type of parameter.
            There are three types of date string inputs:
                a. ISO Date, or ISO 8601,:
                        const variableName = new Date("yyyy-mm-dd");
                    or
                        const variableName = new Date("yyyy-mm-ddThour:minute:secondZ");
                    The date and time parameters are separated by capital "T". 
                    UTC is defined by capital "Z".
                b. Short Date: 
                    const variableName = new Date("mm/dd/yyyy");
                c. Long Date:
                        const variableName = new Date("mmm dd yyyy");
                    or
                        const variableName = new Date("dd mmm yyyy");
                    The "month" paramter can be written in full or abbreviated.
        3. Date Ouput:
            Date output is indepenedent of Date input.
            By default, date is returned in full text string format.
                WeekDay Month Date Year hour:minute:second GMT-xxxx (Eastern Daylight Time)
            There are other types of date ouput methods:
                a. variableName.toString():
                    This has the same output as variableName alone.
                b. variableName.toUTCString():
                    This returns date in UTC standard format.
                        WeekDay, dd mmm yyyy hour:minute:second GMT
                c. variableName.toDateString():
                    This returns date in a more readable date string format.
                        WeekDay mmm dd yyyy
                d. variableName.toISOString():
                    This returns date in ISO standard format.
                        yyyy-mm-ddThour:minute:secondZ
        4. Date Conversion:
            Dates are stored as number of milliseconds since Zero Time.
                Jan 01, 1970 00:00:00 UTC (Universal Time Coordinated)
            a. to convert from date to milliseconds:
                let variableName = Date.parse("date string");
            b. to convert from milliseconds to date:
                const variableName = new Date(millisecond);
            c. to convert date to a number:
                let numberName = Number(new Date());
            d. to convert date to a string:
                let stringName = String(Date());
        5. Date Methods:
            Full list of get Date methods: https://www.w3schools.com/js/js_date_methods.asp
            Full list of set Date methods: https://www.w3schools.com/js/js_date_methods_set.asp
            Full list of Date reference: https://www.w3schools.com/jsref/jsref_obj_date.asp
    IV. Math Object:
        The Math object lets you perform mathematical tasks on numbers.
        The Math object has no constructor; therefore, it is static, and its properties and methods can be accessed without declaring the object.
        1. Math Properties:
            There are 8 mathematical constants that can be accessed as Math properties:
                a. Math.E
                b. Math.PI
                c. Math.SQRT2
                d. Math.SQRT1_2
                e. Math.LN2
                f. Math.LN10
                g. Math.LOG2E
                h. Math.LOG10E
        2. Math Methods:
            a. let numberName = Math.round(number);
                This returns a new number rounded to the nearest integer as in common rounding rule.
            b. let numberName = Math.ceil(number);
                This returns a new number rounded up to the nearest integer.
            c. let numberName = Math.floor(number);
                This returns a new number rounded down to the nearest integer.
            d. let numberName = Math.trunc(number);
                This returns the integer part of the number.
            e. let numberName = Math.sign(number);
                This returns:
                    -1 if the number is negative
                    0 if the number is 0
                    1 if the number is positive
            f. let numberName = Math.pow(x, y);
                This returns x to the power of y.
                SIDE NOTE:
                            Math.pow(x, y) = x ** y
            g. let numberName = Math.sqrt(x);
                This returns the square root of x.
                SIDE NOTE:
                            Math.sqrt(x) = Math.pow(x, 1/2) = x ** 1/2
            h. let numberName = Math.abs(number);
                This returns the absolute value of the number.
            i. 
                let numberName = Math.min(list of numbers);
                    This returns the smallest value in a list of numbers.
                let numberName = Math.max(list of numbers);
                    This returns the largest value in a list of numbers.
            j. let numberName = Math.random();
                This returns a random number between 0 (inclusive) and 1 (exclusive).
                SIDE NOTE:
                            to find a random number 0 (inclusive) and x (exclusive):
                                let numberName = Math.floor(Math.random() * (x + 1)) = Math.ceil(Math.random() * x);
            Full list of Math reference: https://www.w3schools.com/js/js_math.asp
    V. Set:
        A set is a collection of unique values, each of which can only occur once in the set.
        1. Set Properties:
            to return the number of elements in a set:
                let numberName = setName.size;
        2. Set Methods:
            a. to create a new set:
                a.1 to create a new set from an array:
                    const setName = new Set([item0, item1, item2]);
                a.2 to create a new set then add values:
                    const setName = new Set();
                    setName.add(value0);
                    setName.add(value1);
                    setName.add(value2);
            b. to add a new element to a set:
                    setName.add(value);
                If the added element is duplicate, only the first occurrence is saved in the set.
            c. to remove an element from a set:
                delete();
            d. to check if a value exists in a set:
                has();
            e. to invoke a callback function for each element in a set:
                const setName = new Set([item0, item1, item2]);
                setName.forEach(function(value) {
                        action to be executed;
                    }
                );
            f. to return an iterable object containing all the elements in a set:
                    const objectName = setName.values();
                You can use for/of loop to display the object.
    VI. Map:
        A map holds key-value pairs, where the keys and values can be of any datatype.
        A map can remember the original insertion order of the keys.
        1. Map Properties:
            to return the number of elements in a map:
                let numberName = mapName.size;
        2. Map Methods:
            a. to create a new map:
                a.1 to create a new map from an array:
                    const mapName = new Map([
                            [key0, value0],
                            [key1, value1],
                            [key2, value2]
                        ]
                    );
                a.2 to create a new map then set values:
                    const mapName = new Map();
                    mapName.set(key0, value0);
                    mapName.set(key1, value1);
                    mapName.set(key2, value2);
            b. to set a key and a value for the key in a map:
                b.1 to add a new key-value pair to a map:
                    mapName.set(key, value);
                b.2 to change the value of an existing key in a map:
                    mapName.set(key, newValue);
            c. to get the value of a key in a map:
                let valueName = mapName.get(key);
            d. to remove an element in a map:
                mapName.delete(key);
            f. to check if a key exists in a map:
                let booleanName = mapName.has(key);
            e. to invoke a callback function for each element in a map:
                const mapName = new Map([
                        [key0, value0],
                        [key1, value1],
                        [key2, value2]
                    ]
                );
                mapName.forEach(function(value, key) {
                        action to be executed;
                    }
                );
            g. to return an iterable object containing all the elements in a map:
                    const objectName = mapName.entries();
                You can use for/of loop to display the object.
    VII. Class:
        Classes are basically templates/blueprints/constructors for creating objects.
        to create a class:
            class className {
                constructor(parameter1, parameter2) {
                    this.propertyName1 = parameter1;
                    this.propertyName2 = parameter2;
                }
                methodName1(parameter1, parameter2) {
                    action to be executed;
                }
                methodName2(parameter1, parameter2) {
                    action to be executed;
                }
            }
        All the parameters and arguments are optional.
        1. Class Declaration:
            to create an object from a class:
                const objectName = new className(argument1, argument2);
            Class declarations are not hoisted.
        2. Properties:
            to access the object properties:
                let variableName1 = objectName.propertyName1;
                let variableName2 = objectName.propertyName2;
        3. Methods:
            to access the object methods:
                let variableName1 = objectName.methodName1(argument1, argument2);
                let variableName2 = objectName.methodName2(argument1, argument2);
        4. Constructor:
            - is a special method.
            - is used to initialize object properties.
            - is executed automatically when an object is created.
            - if not defined, JavaScript will autoamatically add an empty one.
                constructor() { }
        5. Inheritance:
            A class created with a class inheritance inherits all the methods from the parent class.
            to create a class inheritance with "extends" keyword:
                class className2 extends className1 {
                    constructor(parameter1, parameter2, parameter3) {
                        super(parameter1, parameter2);
                        this.propertyName3 = parameter3;
                    }
                    methodName3(parameter1, parameter2) {
                        action to be executed;
                    }
                }
            The "super()" method prefers to the parent constructor amd gives access to the parent properties and methods.
        6. Getters and Setters:
            to add a getter or a setter with "get" and "set" keywords:
                class className {
                    constructor(parameter1, parameter2) {
                        this.propertyName1 = parameter1;
                        this.propertyName2 = parameter2;
                    }
                    get property1() {
                        return this.propertyName1;
                    }
                    set property1(value) {
                        this.propertyName1 = value;
                    }
                    methodName1(parameter1, parameter2) {
                        action to be executed;
                    }
                    methodName2(parameter1, parameter2) {
                        action to be executed;
                    }
                }
            to get a property:
                let variableName = objectName.property1;
            to set a new value for a property:
                objectName.property1 = newValue;
            When naming the getter/setter, name differently from the property name.
            When calling the getter/setter, don't use parentheses ().
        7. Static Methods:
            Static class methods are defined and called on the class itself not on the object.
                class className {
                    constructor(parameter1, parameter2) {
                        this.propertyName1 = parameter1;
                        this.propertyName2 = parameter2;
                    }
                    methodName1(parameter1, parameter2) {
                        action to be executed;
                    }
                    methodName2(parameter1, parameter2) {
                        action to be executed;
                    }
                    static methodName3(parameter1, parameter2) {
                        action to be executed;
                    }
                }
            to call the static method:
                className.methodName3(argument1, argument2);
        8. Prototype:
            "prototype" is a property available with all JavaScript objects, which allows new properties and methods to be added to the objects.
                a. Property:
                    ObjectName.prototype.propertyName = value;
                b. Method:
                    ObjectName.prototype.methodName = function(parameter1, parameter2) {
                        action to be executed;
                    }
            EX:
                to add a new method to the Array Object:
                    Array.prototype.methodName = function() {
                        action to be executed;
                    }
                    const arrayName = [item0, item1, item2];
                    const variableName = arrayName.methodName(); 

WHAT ARE JAVASCRIPT CONDITIONAL STATEMENTS?
    Conditional statements are used to perform different actions based on different conditions.
    I. If Statement:
        if (condition) {
            action to be executed if condition is true
        }
    II. Else If Statement:
        else if (condition) {
            action to be executed if the previous condition is false and the current condition is true
        }
    III. Else Statement:
        else {
            action to be executed if all previous conditions are false
        }
    IV. Switch Statement:
        This executes alternative actions in different conditions.
            switch (expression) {
                case value1:
                    action1;
                    break;
                case value2:
                    action2;
                    break;
                default:
                    defaultAction;
            }
        If multiple cases share the same action,
            switch (expression) {
                case value1:
                case value2:
                    action1;
                    break;
                case value3:
                case value4:
                    action2;
                    break;
                default:
                    defaultAction;
            }
        The "break" statement is used for stopping the execution inside the switch block and breaking out of the switch block if the matching case is found. If the "break" statement is ommitted, the next case will be executed even if the case value doesn't match the evaluation. The last case doesn't need a "break" since the execution ends there anyway.
        The "default" statement specified an action to be executed if no matching cases is found.
        If multiple cases match the evaluation, the first occurence will be executed.
        If no matching cases and no "default" are found, the program will continue to the code after the switch block. 
    SIDE NOTE:
                There is a similarity between if-else statement and conditional/ternary operator:
                    if-else statement:
                        if (condition) {
                            action to be executed if condition is true;
                        } else {
                            action to be executed if condition is false;
                        }
                    conditional/ternary operator:
                        let variableName = (condition) ? value1 : value2;

WHAT ARE JAVASCRIPT LOOPS?
    Loops are used to iterate over iterable objects to execute a code block, with a different value after every iteration.
    SIDE NOTE:
                Iterables are iterable objects, that can be iterated over with loops.
                Iterating means looping over a sequence of elements.
    I. For Loop:
            for (expression1; expression2; expression3) {
                action to be executed;
            }
        to iterate over an array:
            const arrayName = [item0, item1, item2];
            for (let i = 0; i < arrayName.length; i++) {
                action to be executed;
                use arrayName[i] to access to the values;
            }
        All three expressions are optional.
        Expression 1 declares and initializes the variable(s) used in the loop separated by comma and is executed once before the execution of the loop. If expression 1 is omitted, you have to declare and initialize the variable(s) before the loop.
            let variable1 = value1, variable2 = value2, variable3 = value3;
            for ( ; expression2; expression3) {
                action to be executed;
            }
        Expression 2 specifies the condition for the iteration. If expression 2 is omitted, you have to specify the running/stopping condition inside the loop.
            for (expression1; ; expression3) {
                action to be executed;
                specify condition;
            }
        Expression 3 specifies the counter of the loop and is executed after every iteration. If expression 3 is omitted, you have to specify the counter inside the loop.
            for (expression1; expression2; ) {
                action to be executed;
                specify counter;
            }
    II. For/In Loop:
        This loops through properties of an iterable object.
        1. to iterate over an array:
                const arrayName = [item0, item1, item2];
                for (let x in arrayName) {
                    action to be executed;
                    use arrayName[x] to access to the values;
                }
            "x" specifies the array indexes, but the indexes are in type string; therefore, to use the indexes, you have to typecast it to Number(i).
            To get access to the element values, you have to use arrayName[x].
            If the index order is crucial in the execution, don't use for/in loop over an array. 
        2. to iterate over an object:
                const objectName = {name0:value0, name1:value1, name2:value2};
                for (let x in objectName) {
                    action to be executed;
                    use objectName[x] to access to the values;
                }
            "x" specifies the object properties.
            To get access to the property values, you have to use objectName[x].
    III. For/Of Loop:
        This loops through values of an iterable object.
        1. to iterate over a string:
                let stringname = "abcxyz";
                for (let x of stringName) {
                    action to be executed;
                    use x to access to the values;
                }
            "x" specifies the values of the string characters, so "x" can be used directly to access to the values.
        2. to iterate over an array:
                const arrayName = [item0, item1, item2];
                for (let x of arrayName) {
                    action to be executed;
                    use x to access to the values;
                }
            "x" specifies the values of the array elements, so "x" can be used directly to access to the values.
    IV. While Loop:
        This executes a code block based on some conditions.
            while (condition) {
                action to be executed;
            }
        This checkes the condition before executing the code.
        There is a chance that the code won't be executed at all if the condition is false in the first time.
        As long as the condition is true, the execution goes on.
    V. Do/While Loop:
        This executes a code block based on some conditions.
            do {
                action to be executed;
            } while (condition);
        This executes the code before checking the condition (in the first time only).
        The code will always be executed at least once even if the condition is false in the first time.
        As long as the condition is true, the execution goes on.

WHAT ARE JAVASCRIPT KEYWORDS THAT YOU SHOULD KNOW?
    I. this
        The "this" keyword refers to an object, and to which object depends on how "this" is invoked, used, or called.
        1. in a function:
            In default function binding, "this" refers to the global object.
            In "strict mode", "this" is defined as "undefined".
            When the function is called by an object:
                - if the function is declared with the "function" keyword or "function()" method, "this" refers to the object that calls it.
                - if the function is declared with the arrow function, "this" refers to the global object.
        2. in an object method:
            "this" refers to the object that calls the method.
            Explicit function binding:
                a. call()
                    https://www.w3schools.com/js/js_function_call.asp
                b. apply()
                    https://www.w3schools.com/js/js_function_apply.asp
                c. bind()
                    https://www.w3schools.com/js/js_function_bind.asp
        3. in an event handler:
            "this" refers to the HTML element that receives the event.
        4. by itself:
            "this" refers to the global object.
            In "strict mode", "this" also refers to the global object.
        SIDE NOTE:
                    In a browser window, the global object is the Window object [object Window].
    II. break;
        The "break" statement is used to jump out of, or break, a conditional statement or a loop.
        The "break" statement can be used to jump out of, or break, a code block with a label reference.
            label:
                statement;
        or
            label: {
                code block;
            }
    III. continue;
        The "continue" statement is used to jump over one iteration and continue with the next iteration of a loop.

WHAT IS JAVASCRIPT ERROR HANDLING?
    When executing code, different errors might occur due to different reasons.
    I. Error Object:
        JavaScript has a built-in Error object that provides error information when errors occur.
        Properties:
            1. let stringName = err.name;
                This can set or return an error name.
            2. let stringName = err.message;
                This can set or return an error message.
            3. let stringName = err;
                This returns both error name and message.
        Full reference: https://www.w3schools.com/jsref/jsref_obj_error.asp
    II. Error Handlers:
        1. Try-Catch Statement:
            try {
                code block defined to be tested for errors while being executed;
            } catch(err) {
                code block defined to handle errors that might occur in the try block;
            }
        2. Throw Statement:
            Throw an exception, or throw an error, means when an error occurs, JavaScript will stop and generate an error message.
            This allows you to create and throw a custom exception, or error.
                try {
                    action to be executed;
                    if (condition)
                        throw "error message 1";
                    else (condition)
                        throw "error message 2";
                } catch (err) {
                    action to be executed if error occurs;
                }
            The "error message" can be a Number, String, Boolean, or an Object.
        3. Finally Statement:
            try {
                action to be executed;
            } catch(err) {
                action to be executed if error occurs;
            } finally {
                code block defined to be executed regardless of the result;
            }

WHAT ARE JAVASCRIPT MODULES?
    Modules allow you to break up your code into separate files, which makes it easier to maintain the code-base.
    I. Import Statement:
        You can import modules into a file.
        1. from named export:
            import {variableName1, variableName2} from "fileName.js";
        2. from default export:
            import variableName from "fileName.js";
    II. Export Statement:
        You can export a variable or function from one file to another.
        1. Named Export:
            a. in-line individually:
                export const variableName1 = value1;
                export const variableName2 = value2;
            b. all at once at the bottom:
                const variableName1 = value1;
                const variableName2 = value2;
                export {variableName1, variableName2};
        2. Default Export:
            You can have only one default export in a file.
                const variableName = value;
                export default variableName;

WHAT IS DOM?
    DOM, stands for Document Object Model, is a W3C, World Wide Web Consortium, standard platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document.
    There are 3 parts of the W3C DOM:
        1. Core DOM:
            This is a standard object model for all document types.
        2. XML DOM:
            This is a standard object model for XML documents.
        3. HTML DOM:
            This is a standard object model and programming interface for HTML documents.
    I. HTML DOM:
        1. HTML DOM Navigation:
            When a Web page is loaded, the Web browser creates a Document Object Model of the HTML page, where the HTML DOM is constructed as a tree of Objects.
            a. HTML DOM Navigation as Object Tree:
                All the HTML elements are objects.
                The programming interface is the properties and methods of each object.
                    - the properties - which are values of the HTML elements that you can get/set/change
                    - the methods - which are actions that you can perform on the HTML elements
                With the HTML DOM, JavaScript can access/create/change/add/remove all the HTML elements, access/create/change/add/remove CSS styles, and create/react to HTML events.
            b. HTML DOM Navigation as Node Tree:
                Everything in an HTML document is a node.
                    The "DOCTYPE" is a document type node.
                    The HTML document itself is a document node.
                    Every HTML element is an element node.
                    Every HTML attribute is an attribute node.
                    All the text inside HTML elements are text nodes. 
                    All comments are comment nodes.
                    SIDE NOTE:
                                Element nodes don't contain text. They contain text nodes with the text value.
                The nodes in the node tree have a hierarchical relationship (parent-child-sibling).
                    The top node is the root/root element/root node.
                    Except the root node, every node has one parent.
                    One node can have one or more children.
                    Nodes with the same parent are siblings.
                With the HTML DOM, all nodes in the node tree can be navigated using node relationships, and JavaScript can access/create/change/add/remove all nodes.
                b.1 to navigate between nodes:
                    objectName.parentNode
                    objectName.childNodes
                    objectName.childNode[index]
                    objectName.firstChild
                    objectName.lastChild
                    objectName.nextSibling
                    objectName.previousSibling
                b.2 to access the name of a node:
                    objectName.nodeName
                b.3 to access the value of a node:
                    objectName.nodeValue
                b.4 to access the type of a node:
                        objectName.nodeType
                    If it is an element node, it returns 1.
                    If it is an attribute node, it returns 2.
                    If it is a text node, it returns 3.
                    If it is a comment node, it returns 8.
                    If it is a document node, it returns 9.
                    If it is a document type node, it returns 10.
        2. HTML DOM Document:
            The "document" object represents the Web page and is the owner of all other objects in the Web page.
            To access or manipulate any HTML elements, you have to access the document object first.
            a. to access HTML element(s):    
                a.1 to access an HTML element by id:
                    const objectName = document.getElementById("id");
                a.2 to access multiple HTML elements by class name:
                    const objectName = document.getElementsByClassName("class-name");
                a.3 to access multiple HTML elements by tag name:
                    const objectName = document.getElementsByTagName("tag-name");
                a.4 to access one or multiple HTML elements by CSS selector:
                    one element:
                        const objectName = document.querySelector("CSS-selector");
                    multiple elements:
                        const objectName = document.querySelectorAll("CSS-selector");
                a.5 to access the document:
                    as full document:
                        document.documentElement
                    as the body of the document:
                        document.body  
                SIDE NOTE:
                            If the element is not found, the method will return "null";
            b. to access/change HTML element(s):
                b.1 to access/change the inner conntent of the HTML element:
                    objectName.innerHTML
                b.2 to access/change the attribute value of the HTML element:
                    with object property:
                        objectName.attributeName
                    with object method:
                        objectName.setAttribute("attributeName" , "new value");
                b.3 to access/change the style of the HTML element:
                    objectName.style.propertyName
            c. to create/add/remove HTML element(s):
                c.1 to create an HTML element:
                    const elementNode = document.createElement("element");
                    const textNode = document.createTextNode("text");
                c.2 to add an HTML element:
                    as the last child of the parent:
                        parentNode.appendChild(childNode);
                    before a specified sibling:
                        parentNode.insertBefore(childNode, siblingNode);
                c.3 to remove an HTML element:
                    the specified child removing itself:
                        childNode.remove();
                    parent removing the specified child:
                        parentNode.removeChild(childNode);
                c.4 to replace an HTML element:
                    parentNode.replaceChild(newChildNode, oldChildNode);
        3. HTMLCollection Object:
            The HTMLCollection object is an array-like list/collection of HTML document elements.
                const collectionName = document.getElementsByClassName("class-name");
                const collectionName = document.getElementsByTagName("tag-name");
            Properties:
                to access the element of the collection:
                    collectionName[index]
                    or by element name or id
                to return the number of elements in the collection:
                    collectionName.length
            Methods:
                The collection might look like an array but is not an array; therefore, it can't use any array methods.
                to access multiple HTML elements by HTMLCollection Object:
                    const collectionName = document.anchors;
                    const collectionName = document.body;
                    const collectionName = document.documentElement;
                    const collectionName = document.embeds;
                    const collectionName = document.forms;
                    const collectionName = document.head;
                    const collectionName = document.images;
                    const collectionName = document.links;
                    const collectionName = document.scripts;
                    const collectionName = document.title;
            The HTMLCollection object is a live collection.
        4. HTML NodeList Object:
            The NodeList object is an array-like list/collection of HTML document nodes.
                const nodeListName = document.querySelectorAll("CSS-selector");
                const nodeListName = parentNode.childNodes;
            Properties:
                to access the element of the node list:
                    nodeListName[index]
                to return the number of elements in the node list:
                    nodeListName.length
            Methods:
                The collection might look like an array but is not an array; therefore, it can't use any array methods.
            The NodeList object is almost a static collection.
    III. HTML DOM Form:
        Data validation is the process of ensuring that the user input is clean, correct, and useful.
        There are 2 types of data validation:
            1. Client Side Validation: is performed by the Web browser before the input is sent to the Web server.
            2. Server Side Validation: is performed by the Web server after the input has been sent to the Web server.
        HTML Constraint Validation:
            1. Constraint Validation HTML Input Attributes:
                disabled
                max
                min
                pattern
                required
                type
                Full reference: https://www.w3schools.com/html/html_form_attributes.asp
            2. Constraint Validation CSS Pseudo Selectors:
                :disabled
                :invalid
                :optional
                :required
                :valid
                Full reference: https://www.w3schools.com/css/css_pseudo_classes.asp
            3. Constraint Validation DOM Properties and Methods:
                Properties:
                    a. to relate to the validity of an input element:
                        objectName.validity.customError
                        objectName.validity.patternMismatch
                        objectName.validity.rangeOverflow
                        objectName.validity.rangeUnderflow
                        objectName.validity.stepMismatch
                        objectName.validity.tooLong
                        objectName.validity.typeMismatch
                        objectName.validity.valueMissing
                        objectName.validity.valid
                    b. to display a validation message:
                        objectName.validationMessage
                    c. to indicate if an input element will be validated:
                        objectName.willValidate
                Methods:
                    a. to check if an input element contains valid data:
                        objectName.checkValidity()
                    b. to set a custom validation message of an input element:
                        objectName.setCustomValidity()
                Full reference: https://www.w3schools.com/js/js_validation_api.asp
        Form Validation:
            HTML:
                <form name="formName" action="/xyz.php" onsubmit="return functionName()" method="post">
                    <label>XYZ</label>
                    <input name="inputName" type="text" value="xyz">
                    <button type="submit">Submit</button>
                </form>
            Js:
                const functionName = () => {
                    let variableName = document.form["formName"]["inputName"].value;
                    action to be executed;
                }
    IV. HTML DOM Animation:
        Animations are done by programming gradual changes in an element' style. The changes are called by a timer. When the timer interval is small, the animation looks continuous.
        Animation Code:
            HTML:
                <div id="container">
                    <div id="item"></div>
                </div>
            CSS:
                #container {
                    display: block/inline-block/flex/grid;
                    position: relative;
                }
                #item {
                    position: absolute;
                }
            Js:
                const variableName = document.getElementById("item");
                let id = null;
                clearInerval(id);
                id = setInterval(animate, 5);
                function animate() {
                    if (condition to stop animation) {
                        clearInteravl(id);
                    } else {
                        action to be executed;
                    }
                }
    V. HTML DOM Event Handling:
        Events are things that happen to the elements of the Web page.
        EX:
            An HTML Web page has finished loading.
            An HTML button was clicked.
            An HTML input field was changed.
        When an event is detected, JavaScript can react on the event and execute the code.
        There are 2 ways of event handling:
        1. Event Handlers:
            JavaScript can either be added to an event handler attribute of an HTML element to react on the assigned event or directly use an event handler to assign an event to an HTML element via HTML DOM.
            Each element can only be assigned with one event handler for one specific event.
            Duplicate event handlers will be overridden by the latest one.
            Event Handler Code:
                HTML:
                    <div event-handler-attribute="action to be executed"></div>
                    <script>
                        action to be executed;
                    </script>
                Js:
                    const objectName = document.getElementById("id");
                    objectName.event-handler-attribute = action to be executed;
            Some HTML event handler attributes are:
                onchange
                onclick
                onmouseover
                onmouseout
                onmousedown
                onmouseup
                onkeydown
                onload
                onunload
                onmessage
        2. Event Listeners:
            JavaScript can use event listener to assign an event to an HTML element or any DOM object with:
                addEventListener("event", function, useCapture);
            or to remove event listeners with:
                removeEventListener("event", function)
            Each element can be assigned with as many event listeners for one specific event.
            Duplicate event listeners doesn't overwrite existing ones.
            HTML DOM Event Propagation is a way of defining the order of the element when an event occurs.
                a. Event Bubbling:
                    The event of inner most element is handled first, then the outer.
                b. Event Capturing:
                    The event of outer most element is handled first, then the inner.
                If it's specified as false, the propagation is in bubbling. If it's specified as true, the propagation is in capturing. By default, the "useCapture" parameter is false.
            Event Listener Code:
                Js:
                    const objectName = document.getElementById("id");
                    objectName.addEventListener("event", action to be executed);
                    objectName.removeEventListener("event", action to be executed);
        Full reference of event handlers: https://www.w3schools.com/jsref/dom_obj_event.asp
    VI. Data Display:            
        1. to display content in the console:
            console.log(content);
        2. to display content in an alert box of the Web browser:
            window.alert(content);
        3. to print the content of the current Web page:
            window.print();
        4. to prompt the user input fron an alert box of the Web browser:
            prompt(question);
        5 to write into the HTML output stream:
                document.write(content);
            This should be used for testing only. 
            If it is used after the HTML document is loaded, it will overwrite all existing HTML content.   
        SIDE NOTE:
                    The window object is a DOM object with a globel scope. All variables, properties, and methods belong to the window object by default. Therefore, specifying the "window" keyword is optional.

WHAT IS WEB API?
    API, stands for Application Programming Interface, is a way to help program communicate with servers to fetch data.
    I. Web API:
        A Web API is an API for the Web.
        1. Web History API:
            URL, stands for Uniform Resource Locator, is a reference to a Web resource that specifies its location on the computer network and the mechanism for retrieving it. URL, or Web site, is the address of a Web page.
            The Web history API allows access to the browsing history of the current window.
            The window.history object contains the URLs visited by the user.
            Properties:
                to return the number of URLs in the history list of the current browser window:
                    window.history.length
            Methods:
                a. to load the previous URL in the history list:
                    window.history.back();
                b. to load the next URL in the history list:
                    window.history.forward();
                c. to load a specific URL from the history list:
                        window.history.go(number);
                    If the "number" parameter is negative, the page loads back. If the "number" parameter is 0, it reloads the current page. If the "number" parameter is positive, the page loads forward.
        2. Web Storage API:
            The Web storage API allows to store and retrieve data in the Web browser.
            There are 2 types of Web storage object:
                a. window.localStorage:
                    The localStorage object provides access to a local storage for a particular Web site and allows to store/read/modify/add/remove data items in a Web browser.
                    The data is stored without expiratin date and won't be removed when the browser is closed.
                b. window.sessionStorage:
                    The sessionStorage object provides access to a local storage for a particular Web site and allows to store/read/modify/add/remove data items in a Web browser but only for one session.
                    The data will be removed when the browser is closed.
            Properties:
                to return the number of data items stored in the storage:
                    .length
            Methods:
                a. to store a data item in a storage:
                    .setItem("name", "value")
                b. to retrieve a data item from the storage:
                    .getItem("name")
                c. to remove a data item from the storage:
                    .removeItem("name")
                d. to return the name of a specific key in the storage:
                    .key(index)
                e. to empty all keys out of the storage:
                    .clear()
        3. Web Worker API:
            The Web worker API is an independent script running in the background without affecting the performance of the Web page.
            a. to check if Web worker is supported:
                if (typeof(Worker) !== "underfined") {
                    action to be executed;
                }
            b. to create a Web worker:
                b.1 in an external file:
                    - create a worker file: "fileName.js"
                    - the "postMessage(data)" method is used to post a message back to the main file.
                b.2 in the main file:
                    - check if the worker already exists:
                        let objectName;
                        if (typeof(objectName) == "underfined") {
                            objectName = new Worker("fileName.js");
                        }
                    - the "onmessage" event listener provides a mean to send/receive messages from the worker.
                    - when the worker posts a message, JavaScript reacts on the event and executes the function.
                    - the data received from the worker will be stored in "event.data" and can be used further.
                        objectName.onmessage = (event) => {
                            action to be executed;
                        };
            c. to terminate the Web worker:
                objectName.terminate();
            d. to reuse the Web worker:
                objectName.terminate();
                objectName = underfined;
            When a Web worker is created, it will continue to listen for messages, even after the external script is finished, until it is terminated to free the Web browser/computer resources.
            Because the Web worker is in an external file, it doesn't have access to the window, document, and parent objects.
        4. Web Geolocation API:
            The Geolocation API allows to get the geographical position of the user.
            a. to check if Web geolocation is supported:
                if (navigator.geolocation) {
                    action to be executed;
                }
            b. to get the user's position:
                b.1 getCurrentPosition():
                    navigator.geolocation.getCurrentPosition(showPosition, showError);
                b.2 watchPosition():
                    navigator.geolocation.watchPosition(showPosition, showError);
                b.3 showPosition():
                    const showPosition = (position) => {
                        x.innerHTML = "Latitude: " + position.coords.latitude +
                                    "<br>Longitude: " + position.coords.longitude;
                    };
                b.4 to display the position on a map:
                    const showPosition = (position) => {
                        let latlon = position.coords.latitude + "," + position.coords.longitude;
                        let img_url = "https://maps.googleapis.com/maps/api/staticmap?center=
                        "+latlon+"&zoom=14&size=400x300&sensor=false&key=YOUR_KEY";
                        x.innerHTML = `<img src="${img_url}">`;
                    };
                b.5 showError():
                    const showError = (err) => {
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                            x.innerHTML = "User denied the request for Geolocation."
                            break;
                            case error.POSITION_UNAVAILABLE:
                            x.innerHTML = "Location information is unavailable."
                            break;
                            case error.TIMEOUT:
                            x.innerHTML = "The request to get user location timed out."
                            break;
                            case error.UNKNOWN_ERROR:
                            x.innerHTML = "An unknown error occurred."
                            break;
                        }
                    };
        5. Web Fetch API:
            The Fetch API allows Web browsers to make HTTP requests to Web servers.
            Methods:
                fetch("source").then(action to be executed);
    II. Browser API:
        A browser API can extend the functionality of a Web browser. 
        All browsers have a set of built-in Web APIs to support complex operations and to help accessing data.
    III. Server API:
        A server API can extend the functionality of a Web server.

WHAT IS ASYNCHRONOUS PROGRAMMING?
    I. Function Sequence:
        JavaScript functions are executed in the sequence they are called, not in the sequence they are defined.
    II. Callback:
        A callback is a function passed as an argument to another function. 
        This technique allows a function to call another function.
            const functionName1 = (parameter1, parameter2) => {
                action to be executed;
            };
            const functionName2 = (parameter1, parameter2, functionName) => {
                action to be executed;
            };
            functionsName2(argument1, argument2, functionName1);
        When passing a function as an argument:
            DO:
                - function name: functionName
                - complete function, or function definition: () => {}
            DON'T:
                - function invocation: functionName()
    III. Asynchronous:
        Asynchronous functions are functions running in parallel with other functions; in other words, they run out of order based on a set time.
        1. setTimeout():
                const functionName = (parameter1, parameter2) => {
                    action to be executed;
                };
                let timeoutID = setTimeout(functionName, timer, argument1, argument2);
            This sets a timer which executes a function once the timer expires; in other words, the function will only be invoked once.
            This returns a non-zero timeout ID which uniquely identifies the timer so it can be removed later.
            The "timer" parameter specifies the time in milliseconds of when the function should be invoked.
            To cancel setTimeout():
                clearTimeout(timeoutID);
                timeoutID = null;
        2. setInterval():
                const functionName = (parameter1, parameter2) => {
                    action to be executed;
                };
                let intervalID = setInterval(functionName, timer, argument1, argument2);
            This repeatedly calls a function with a fixed time delay between each call; in other words, the function will be invoked once every set time.
            This returns a non-zero interval ID which uniquely identifies the timer so it can be removed later.
            The "timer" parameter specifies the time in milliseconds of when the function should be invoked.
            To cancel setInterval():
                clearInterval(intervalID);
                intervalID = null;
        SIDE NOTE:
                    The same object that uses these functions might share the same pool of IDs. However, different objects use separate pools of IDs.
                    In often time, using "setTimeout()" or "setInterval()" can be thread-blocking, which means it might block other code to be executed, as in case it reduces errors; therefore, you need to use Promise.
    IV. Promise:
        Producing code is code that can take some time.
        Consuming code is code that must wait for the result.
        A Promise is an object that links producing code and consuming code.
        It contains both the producing code and calls to the consuming code.
            let objectName = new Promise((resolve, reject) => {
                action to be executed;
                use "resolve(value) when successful; 
                use "reject(error) when error;  
            });
            objectName.then(
                (value) => {
                    action to be executed;
                },
                (error) => {
                    action to be executed;
                }
            );
        Properties:
            A Promise object has 2 properties:
                objectName.state
                objectName.result
            A Promise object can be:
                1. pending/working:
                    The result is undefined.
                2. fulfilled:
                    The result is a value.
                3. rejected:
                    The result is an error object.
            You can't directly access the properties but have to use methods to handle promises.
        Methods:
            The "then()" method takes up to 2 arguments:
                - one callback for success
                - one callback for failure
    V. Async/Await:
        Async/Await make promises easier to write.
        1. async:
            This makes a function return a Promise.
            instead of:
                let objectName = new Promise(resolve => resolve(value));
                objectName.then(
                    (value) => {
                        action to be executed;
                    }
                );
            or:
                function functionName() => {
                    return Promise.resolve(value);
                };
                functionName().then(
                    (value) => {
                        action to be executed;
                    }
                );
            write:
                async function functionName() {
                    return value;
                };
                functionName().then(
                    (value) => {
                        action to be executed;
                    }
                );
        2. await:
            This can only be used inside an "async" function.
            This makes a function pause the execution and wait for a resolved Promise before it continues.
            instead of:
                let objectName = new Promise(resolve => resolve(value));
                objectName.then(
                    (value) => {
                        action to be executed;
                    }
                );
            or:
                async function functionName() {
                    return value;
                };
                functionName().then(
                    (value) => {
                        action to be executed;
                    }
                );
            write:
                async function functionName() {
                    let objectName = new Promise(resolve => resolve(value));
                    use "await objectName" to act on the resolved value;
                };
            SIDE NOTE:   
                        If a "Promise{}" is returned, the function is likely to be an "async" function. 
                        In other to extract the data from it, you have to use either "then()" method or "await" keyword.

WHAT IS JSON?
    JSON, stands for JavaScript Object Notation, is a lightweight data interchange format for storing and transporting data, which is often used when data is sent from a Web server to a Web page. 
    JSON is language independent, which means the code for reading and generating JSON can be written in any programming language, and self-describing, which means JSON format is text only.
    JSON format is syntactically identical to the code for creating JavaScript objects because JSON format is deprived from JavaScript object notation syntax. Therefore, a JavaScript program easily converts JSON data to native JavaScript objects.
    Syntax:
        1. JSON data is written in name:value pairs.
            { "fieldName":"value" }
        2. JSON data is separated by commas.
        3. JSON objects are written in curly braces {}.
        4. JSON arrays are written in square brackets [].
